<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Tasks</title>
    <style>
        body {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
            align-items: center;
            height: 100vh;
            margin: 0;
        }
        canvas {
            border: 1px solid black;
            margin: 10px;
        }
    </style>
</head>
<body>
    <canvas id="tetrahedron" width="400" height="400"></canvas>
    <canvas id="cube-texture" width="400" height="400"></canvas>
    <canvas id="cube-mixed-textures" width="400" height="400"></canvas>
    <canvas id="gradient-circle" width="400" height="400"></canvas>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js "></script>
    <script>
        // Common WebGL setup function
        function setupWebGL(canvas) {
            const gl = canvas.getContext("webgl");
            if (!gl) {
                alert("WebGL not supported!");
                return null;
            }
            return gl;
        }

        // Common shader compilation function
        function compileShader(gl, source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error("Shader compilation error:", gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        // Common program linking function
        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error("Program linking error:", gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }
            return program;
        }

        // Task 1: Gradient Tetrahedron
        {
            const canvas = document.getElementById("tetrahedron");
            const gl = setupWebGL(canvas);

            const vertexShaderSource = `
                attribute vec3 aPosition;
                uniform mat4 uModelViewMatrix;
                uniform mat4 uProjectionMatrix;
                void main() {
                    gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 1.0);
                }
            `;

            const fragmentShaderSource = `
                precision mediump float;
                uniform vec3 uColor;
                void main() {
                    gl_FragColor = vec4(uColor, 1.0);
                }
            `;

            const vertexShader = compileShader(gl, vertexShaderSource, gl.VERTEX_SHADER);
            const fragmentShader = compileShader(gl, fragmentShaderSource, gl.FRAGMENT_SHADER);
            const program = createProgram(gl, vertexShader, fragmentShader);
            gl.useProgram(program);

            const vertices = [
                // Tetrahedron vertices
                1, 1, 1,
                -1, -1, 1,
                -1, 1, -1,
                1, -1, -1
            ];

            const indices = [
                0, 1, 2,
                0, 1, 3,
                0, 2, 3,
                1, 2, 3
            ];

            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

            const indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

            const aPosition = gl.getAttribLocation(program, "aPosition");
            gl.enableVertexAttribArray(aPosition);
            gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);

            const uModelViewMatrix = gl.getUniformLocation(program, "uModelViewMatrix");
            const uProjectionMatrix = gl.getUniformLocation(program, "uProjectionMatrix");
            const uColor = gl.getUniformLocation(program, "uColor");

            const projectionMatrix = mat4.create();
            mat4.perspective(projectionMatrix, Math.PI / 4, canvas.width / canvas.height, 0.1, 100.0);

            let modelViewMatrix = mat4.create();
            mat4.translate(modelViewMatrix, modelViewMatrix, [0, 0, -5]);

            function draw() {
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                gl.uniformMatrix4fv(uProjectionMatrix, false, projectionMatrix);
                gl.uniformMatrix4fv(uModelViewMatrix, false, modelViewMatrix);
                gl.uniform3f(uColor, 1.0, 0.5, 0.0);
                gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
            }

            function updateModelViewMatrix(dx, dy, dz) {
                mat4.translate(modelViewMatrix, modelViewMatrix, [dx, dy, dz]);
                draw();
            }

            document.addEventListener("keydown", (event) => {
                switch (event.key) {
                    case "ArrowUp":
                        updateModelViewMatrix(0, 0.1, 0);
                        break;
                    case "ArrowDown":
                        updateModelViewMatrix(0, -0.1, 0);
                        break;
                    case "ArrowLeft":
                        updateModelViewMatrix(-0.1, 0, 0);
                        break;
                    case "ArrowRight":
                        updateModelViewMatrix(0.1, 0, 0);
                        break;
                    case "PageUp":
                        updateModelViewMatrix(0, 0, 0.1);
                        break;
                    case "PageDown":
                        updateModelViewMatrix(0, 0, -0.1);
                        break;
                }
            });

            draw();
        }

        // Task 2: Textured Cube with Color Mix
        {
            const canvas = document.getElementById("cube-texture");
            const gl = setupWebGL(canvas);

            const vertexShaderSource = `
                attribute vec3 aPosition;
                attribute vec2 aTexCoord;
                uniform mat4 uModelViewMatrix;
                uniform mat4 uProjectionMatrix;
                varying vec2 vTexCoord;
                void main() {
                    gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 1.0);
                    vTexCoord = aTexCoord;
                }
            `;

            const fragmentShaderSource = `
                precision mediump float;
                uniform sampler2D uTexture;
                uniform float uMixRatio;
                varying vec2 vTexCoord;
                void main() {
                    vec4 textureColor = texture2D(uTexture, vTexCoord);
                    vec4 mixedColor = mix(textureColor, vec4(1.0, 0.5, 0.0, 1.0), uMixRatio);
                    gl_FragColor = mixedColor;
                }
            `;

            const vertexShader = compileShader(gl, vertexShaderSource, gl.VERTEX_SHADER);
            const fragmentShader = compileShader(gl, fragmentShaderSource, gl.FRAGMENT_SHADER);
            const program = createProgram(gl, vertexShader, fragmentShader);
            gl.useProgram(program);

            const vertices = [
                // Cube vertices with texture coordinates
                -1, -1, -1, 0, 0,
                1, -1, -1, 1, 0,
                1, 1, -1, 1, 1,
                -1, 1, -1, 0, 1,
                -1, -1, 1, 0, 0,
                1, -1, 1, 1, 0,
                1, 1, 1, 1, 1,
                -1, 1, 1, 0, 1
            ];

            const indices = [
                0, 1, 2, 0, 2, 3,
                1, 5, 6, 1, 6, 2,
                5, 4, 7, 5, 7, 6,
                4, 0, 3, 4, 3, 7,
                3, 2, 6, 3, 6, 7,
                4, 5, 1, 4, 1, 0
            ];

            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

            const indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

            const aPosition = gl.getAttribLocation(program, "aPosition");
            const aTexCoord = gl.getAttribLocation(program, "aTexCoord");
            gl.enableVertexAttribArray(aPosition);
            gl.enableVertexAttribArray(aTexCoord);
            gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 5 * Float32Array.BYTES_PER_ELEMENT, 0);
            gl.vertexAttribPointer(aTexCoord, 2, gl.FLOAT, false, 5 * Float32Array.BYTES_PER_ELEMENT, 3 * Float32Array.BYTES_PER_ELEMENT);

            const uModelViewMatrix = gl.getUniformLocation(program, "uModelViewMatrix");
            const uProjectionMatrix = gl.getUniformLocation(program, "uProjectionMatrix");
            const uTexture = gl.getUniformLocation(program, "uTexture");
            const uMixRatio = gl.getUniformLocation(program, "uMixRatio");

            const projectionMatrix = mat4.create();
            mat4.perspective(projectionMatrix, Math.PI / 4, canvas.width / canvas.height, 0.1, 100.0);

            let modelViewMatrix = mat4.create();
            mat4.translate(modelViewMatrix, modelViewMatrix, [0, 0, -5]);

            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([255, 255, 255, 255]));

            const image = new Image();
            image.onload = () => {
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                gl.generateMipmap(gl.TEXTURE_2D);
                draw();
            };
            image.src = "texture.jpg"; // Replace with your texture image

            let mixRatio = 0.5;

            function draw() {
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                gl.uniformMatrix4fv(uProjectionMatrix, false, projectionMatrix);
                gl.uniformMatrix4fv(uModelViewMatrix, false, modelViewMatrix);
                gl.uniform1i(uTexture, 0);
                gl.uniform1f(uMixRatio, mixRatio);
                gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
            }

            document.addEventListener("keydown", (event) => {
                switch (event.key) {
                    case "ArrowUp":
                        mixRatio = Math.min(1, mixRatio + 0.1);
                        draw();
                        break;
                    case "ArrowDown":
                        mixRatio = Math.max(0, mixRatio - 0.1);
                        draw();
                        break;
                }
            });

            draw();
        }

        // Task 3: Cube with Mixed Textures
        {
            const canvas = document.getElementById("cube-mixed-textures");
            const gl = setupWebGL(canvas);

            const vertexShaderSource = `
                attribute vec3 aPosition;
                attribute vec2 aTexCoord;
                uniform mat4 uModelViewMatrix;
                uniform mat4 uProjectionMatrix;
                varying vec2 vTexCoord;
                void main() {
                    gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 1.0);
                    vTexCoord = aTexCoord;
                }
            `;

            const fragmentShaderSource = `
                precision mediump float;
                uniform sampler2D uTexture1;
                uniform sampler2D uTexture2;
                uniform float uMixRatio;
                varying vec2 vTexCoord;
                void main() {
                    vec4 color1 = texture2D(uTexture1, vTexCoord);
                    vec4 color2 = texture2D(uTexture2, vTexCoord);
                    vec4 mixedColor = mix(color1, color2, uMixRatio);
                    gl_FragColor = mixedColor;
                }
            `;

            const vertexShader = compileShader(gl, vertexShaderSource, gl.VERTEX_SHADER);
            const fragmentShader = compileShader(gl, fragmentShaderSource, gl.FRAGMENT_SHADER);
            const program = createProgram(gl, vertexShader, fragmentShader);
            gl.useProgram(program);

            const vertices = [
                // Cube vertices with texture coordinates
                -1, -1, -1, 0, 0,
                1, -1, -1, 1, 0,
                1, 1, -1, 1, 1,
                -1, 1, -1, 0, 1,
                -1, -1, 1, 0, 0,
                1, -1, 1, 1, 0,
                1, 1, 1, 1, 1,
                -1, 1, 1, 0, 1
            ];

            const indices = [
                0, 1, 2, 0, 2, 3,
                1, 5, 6, 1, 6, 2,
                5, 4, 7, 5, 7, 6,
                4, 0, 3, 4, 3, 7,
                3, 2, 6, 3, 6, 7,
                4, 5, 1, 4, 1, 0
            ];

            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

            const indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

            const aPosition = gl.getAttribLocation(program, "aPosition");
            const aTexCoord = gl.getAttribLocation(program, "aTexCoord");
            gl.enableVertexAttribArray(aPosition);
            gl.enableVertexAttribArray(aTexCoord);
            gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 5 * Float32Array.BYTES_PER_ELEMENT, 0);
            gl.vertexAttribPointer(aTexCoord, 2, gl.FLOAT, false, 5 * Float32Array.BYTES_PER_ELEMENT, 3 * Float32Array.BYTES_PER_ELEMENT);

            const uModelViewMatrix = gl.getUniformLocation(program, "uModelViewMatrix");
            const uProjectionMatrix = gl.getUniformLocation(program, "uProjectionMatrix");
            const uTexture1 = gl.getUniformLocation(program, "uTexture1");
            const uTexture2 = gl.getUniformLocation(program, "uTexture2");
            const uMixRatio = gl.getUniformLocation(program, "uMixRatio");

            const projectionMatrix = mat4.create();
            mat4.perspective(projectionMatrix, Math.PI / 4, canvas.width / canvas.height, 0.1, 100.0);

            let modelViewMatrix = mat4.create();
            mat4.translate(modelViewMatrix, modelViewMatrix, [0, 0, -5]);

            const texture1 = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture1);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([255, 255, 255, 255]));

            const texture2 = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture2);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([255, 255, 255, 255]));

            const image1 = new Image();
            image1.onload = () => {
                gl.bindTexture(gl.TEXTURE_2D, texture1);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image1);
                gl.generateMipmap(gl.TEXTURE_2D);
                draw();
            };
            image1.src = "texture1.jpg"; // Replace with your texture image

            const image2 = new Image();
            image2.onload = () => {
                gl.bindTexture(gl.TEXTURE_2D, texture2);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image2);
                gl.generateMipmap(gl.TEXTURE_2D);
                draw();
            };
            image2.src = "texture2.jpg"; // Replace with your texture image

            let mixRatio = 0.5;

            function draw() {
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                gl.uniformMatrix4fv(uProjectionMatrix, false, projectionMatrix);
                gl.uniformMatrix4fv(uModelViewMatrix, false, modelViewMatrix);
                gl.uniform1i(uTexture1, 0);
                gl.uniform1i(uTexture2, 1);
                gl.uniform1f(uMixRatio, mixRatio);
                gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
            }

            document.addEventListener("keydown", (event) => {
                switch (event.key) {
                    case "ArrowUp":
                        mixRatio = Math.min(1, mixRatio + 0.1);
                        draw();
                        break;
                    case "ArrowDown":
                        mixRatio = Math.max(0, mixRatio - 0.1);
                        draw();
                        break;
                }
            });

            draw();
        }

        // Task 4: Gradient Circle
        {
            const canvas = document.getElementById("gradient-circle");
            const gl = setupWebGL(canvas);

            const vertexShaderSource = `
                attribute vec2 aPosition;
                uniform mat4 uModelViewMatrix;
                uniform mat4 uProjectionMatrix;
                varying vec2 vPosition;
                void main() {
                    gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 0.0, 1.0);
                    vPosition = aPosition;
                }
            `;

            const fragmentShaderSource = `
                precision mediump float;
                varying vec2 vPosition;
                uniform float uScaleX;
                uniform float uScaleY;
                void main() {
                    float angle = atan(vPosition.y, vPosition.x);
                    float hue = (angle + 3.14159) / (2.0 * 3.14159);
                    vec3 hsv = vec3(hue, 1.0, 1.0);
                    vec3 rgb = hsv2rgb(hsv);
                    float distance = length(vPosition * vec2(uScaleX, uScaleY));
                    float alpha = 1.0 - smoothstep(0.0, 1.0, distance);
                    gl_FragColor = vec4(rgb, alpha);
                }

                vec3 hsv2rgb(vec3 c) {
                    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
                }
            `;

            const vertexShader = compileShader(gl, vertexShaderSource, gl.VERTEX_SHADER);
            const fragmentShader = compileShader(gl, fragmentShaderSource, gl.FRAGMENT_SHADER);
            const program = createProgram(gl, vertexShader, fragmentShader);
            gl.useProgram(program);

            const vertices = [
                // Circle vertices
                -1, -1,
                1, -1,
                1, 1,
                -1, 1
            ];

            const indices = [
                0, 1, 2, 0, 2, 3
            ];

            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

            const indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

            const aPosition = gl.getAttribLocation(program, "aPosition");
            gl.enableVertexAttribArray(aPosition);
            gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);

            const uModelViewMatrix = gl.getUniformLocation(program, "uModelViewMatrix");
            const uProjectionMatrix = gl.getUniformLocation(program, "uProjectionMatrix");
            const uScaleX = gl.getUniformLocation(program, "uScaleX");
            const uScaleY = gl.getUniformLocation(program, "uScaleY");

            const projectionMatrix = mat4.create();
            mat4.ortho(projectionMatrix, -1, 1, -1, 1, -1, 1);

            let modelViewMatrix = mat4.create();
            mat4.translate(modelViewMatrix, modelViewMatrix, [0, 0, -1]);

            let scaleX = 1.0;
            let scaleY = 1.0;

            function draw() {
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                gl.uniformMatrix4fv(uProjectionMatrix, false, projectionMatrix);
                gl.uniformMatrix4fv(uModelViewMatrix, false, modelViewMatrix);
                gl.uniform1f(uScaleX, scaleX);
                gl.uniform1f(uScaleY, scaleY);
                gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
            }

            document.addEventListener("keydown", (event) => {
                switch (event.key) {
                    case "ArrowLeft":
                        scaleX = Math.max(0.1, scaleX - 0.1);
                        draw();
                        break;
                    case "ArrowRight":
                        scaleX = Math.min(2.0, scaleX + 0.1);
                        draw();
                        break;
                    case "ArrowUp":
                        scaleY = Math.min(2.0, scaleY + 0.1);
                        draw();
                        break;
                    case "ArrowDown":
                        scaleY = Math.max(0.1, scaleY - 0.1);
                        draw();
                        break;
                }
            });

            draw();
        }
    </script>
</body>
</html>