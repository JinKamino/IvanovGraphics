<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Генерация полигонов</title>
    <style>
        canvas {
            border: 1px solid black;
            grid-row: 1;
            grid-column: 1;
        }


        button {
            margin-top: 14px;
            height: 25px;
        }

        .input_x_class {

            grid-row: 1;
            grid-column: 1;
            width: 100px;
            margin-top: 30px;
        }

        .input_y_class {

            grid-row: 1;
            grid-column: 2;
            width: 100px;
            margin-top: 30px;
        }

        .angle_input_class {

            grid-row: 1;
            grid-column: 3;
            width: 100px;
            margin-top: 30px;
        }

        .input_x_coord_class {
            grid-row: 1;
            grid-column: 4;
            width: 100px;
            margin-top: 30px;
        }

        .input_y_coord_class {
            grid-row: 1;
            grid-column: 5;
            width: 100px;
            margin-top: 30px;
        }

        .x_scale_input_class {
            grid-row: 1;
            grid-column: 6;
            /* width: 100px; */
            margin-top: auto;
        }

        .y_scale_input_class {
            grid-row: 1;
            grid-column: 7;
            /* width: 100px; */
            margin-top: auto;
        }


        .x_coord_scale_input_class {
            grid-row: 1;
            grid-column: 8;
            /* width: 100px; */
            margin-top: auto;
        }

        .y_coord_scale_input_class {
            grid-row: 1;
            grid-column: 9;
            /* width: 100px; */
            margin-top: auto;
        }

        .wrapper {
            margin-left: 200px;
            display: grid;
            grid-template-columns: repeat(10, 140px);
            /* grid-gap: 35px; */
            /* width: 800px; */
            /* grid-auto-rows: minmax(50px, 100px); */
        }

        input {
            width: 130px;
        }

        #clear {
            /* margin-top: 30px; */
            margin-top: auto;
            color: brown;
        }

        button {
            width: 138px;
        }
    </style>
</head>

<body>

    <canvas id="canvas" ></canvas>


    <div class="wrapper">
        <div class="input_x_class">
            <label for="x_input">x(dx)</label>
            <input type="number" id="x_input" min="0" max="400">
        </div>
        <div class="input_y_class">
            <label for="y_input">y(dy)</label>
            <input type="number" id="y_input" min="0" max="400">
        </div>

        <div class="angle_input_class">
            <label for="angle_input">φ</label>
            <input type="number" id="angle_input" min="0" max="180">
        </div>

        <div class="input_x_coord_class">
            <label for="x_coord_input">x поворота</label>
            <input type="number" id="x_coord_input" min="0" max="400">
        </div>
        <div class="input_y_coord_class">
            <label for="y_coord_input">y поворота</label>
            <input type="number" id="y_coord_input" min="0" max="400">
        </div>

        <div class="x_scale_input_class">
            <label for="x_scale_input">коэф искажения х</label>
            <input type="number" id="x_scale_input">
        </div>
        <div class="y_scale_input_class">
            <label for="y_scale_input">коэф искажения y</label>
            <input type="number" id="y_scale_input">
        </div>

        <div class="x_coord_scale_input_class">
            <label for="x_coord_scale_input">коэф х от точки</label>
            <input type="number" id="x_coord_scale_input">
        </div>
        <div class="y_coord_scale_input_class">
            <label for="y_coord_scale_input">коэф у от точки</label>
            <input type="number" id="y_coord_scale_input">
        </div>
        <button id="clear">Очистить сцену</button>
        <button class="dx_button" onclick="start_moving_polygon()">смещение dx, dy</button>
        <button class="dy_button" onclick="start_moving_polygon_neg()">смещение -dx, -dy</button>
        <button onclick="start_turning_polygon()">φ поворот</button>
        <button onclick="start_turning_polygon_back()">-φ поворот</button>
        <button onclick="start_turning_around_user_dot()">φ(x,y) поворот</button>
        <button onclick="start_turning_back_around_user_dot()">-φ(x,y) поворот</button>
        <button onclick="start_scaling_polygon()">сжать</button>
        <button onclick="start_scaling_back_polygon()">растянуть</button>
        <button onclick="start_scaling_polygon_around_user_dot()">сжать от точки</button>
        <button onclick="start_scaling_back_polygon_around_user_dot()">растянуть от точки</button>

    </div>



    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let polygons = [];
        let currentPoints = [];
        canvas.height=600;
        canvas.width = window.innerWidth-20;
        canvas.addEventListener('click', (event) => {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            currentPoints.push({ x, y });
            drawPolygons();
        });

        canvas.addEventListener('contextmenu', (event) => {
            event.preventDefault();
            if (currentPoints.length > 2) {
                polygons.push(currentPoints);
                currentPoints = [];
            }
            drawPolygons();
        });

        function drawPolygons() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            polygons.forEach(polygon => {
                ctx.beginPath();
                ctx.moveTo(polygon[0].x, polygon[0].y);
                for (let j = 1; j < polygon.length; j++) {
                    ctx.lineTo(polygon[j].x, polygon[j].y);
                }
                ctx.closePath();
                ctx.strokeStyle = 'blue';
                ctx.fillStyle = 'rgba(0, 0, 255, 0.4)';
                ctx.stroke();
                ctx.fill();
            });
            currentPoints.forEach(point => drawPoint(point.x, point.y));
            for (let i = 1; i < currentPoints.length; i += 1) {
                drawLine(currentPoints[i - 1], currentPoints[i]);
            }
        }

        function drawPoint(x, y) {
            ctx.fillStyle = 'red';
            ctx.beginPath();
            ctx.arc(x, y, 5, 0, 2 * Math.PI);
            ctx.fill();
        }

        function drawLine(point1, point2) {
            ctx.beginPath();
            ctx.moveTo(point1.x, point1.y);
            ctx.lineTo(point2.x, point2.y);
            ctx.strokeStyle = 'green';
            ctx.stroke();
        }

        document.getElementById('clear').addEventListener('click', () => {
            polygons = [];
            currentPoints = [];
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        });




        function start_moving_polygon() {
            x = Number(document.getElementById("x_input").value);
            y = Number(document.getElementById("y_input").value);
            move_polygon(x, y);
        }
        function start_moving_polygon_neg() {
            x = -Number(document.getElementById("x_input").value);
            y = -Number(document.getElementById("y_input").value);
            move_polygon(x, y);
        }
        function move_polygon(dx, dy) {
            const translationMatrix = [
                [1, 0, 0],
                [0, 1, 0],
                [dx, dy, 1]
            ];

            polygons = polygons.map(polygon => {
                return polygon.map(point => {
                    const [x, y] = [point.x, point.y];
                    const newPoint = [
                        x * translationMatrix[0][0] + y * translationMatrix[1][0] + translationMatrix[2][0],
                        x * translationMatrix[0][1] + y * translationMatrix[1][1] + translationMatrix[2][1]
                    ];
                    return { x: newPoint[0], y: newPoint[1] };
                });
            });
            drawPolygons();
        }
        function start_turning_polygon() {
            angle = Number(document.getElementById("angle_input").value);
            turn_polygon(angle, canvas.width / 2, canvas.height / 2);
        }
        function start_turning_polygon_back() {
            angle = Number(document.getElementById("angle_input").value);
            turn_polygon_back(angle, canvas.width / 2, canvas.height / 2);
        }
        function start_turning_around_user_dot() {
            x_coord = Number(document.getElementById("x_coord_input").value);
            y_coord = Number(document.getElementById("y_coord_input").value);
            angle = Number(document.getElementById("angle_input").value);
            turn_polygon(angle, x_coord, y_coord);
        }
        function start_turning_back_around_user_dot() {
            x_coord = Number(document.getElementById("x_coord_input").value);
            y_coord = Number(document.getElementById("y_coord_input").value);
            angle = Number(document.getElementById("angle_input").value);
            turn_polygon_back(angle, x_coord, y_coord);
        }
        function start_scaling_polygon() {
            kx = Number(document.getElementById("x_scale_input").value);
            ky = Number(document.getElementById("y_scale_input").value);
            scale_polygon(kx, ky, canvas.width / 2, canvas.height / 2);
        }
        function start_scaling_back_polygon() {
            kx = Number(document.getElementById("x_scale_input").value);
            ky = Number(document.getElementById("y_scale_input").value);
            scale_polygon_back(kx, ky, canvas.width / 2, canvas.height / 2);
        }
        function start_scaling_polygon_around_user_dot() {
            kx = Number(document.getElementById("x_scale_input").value);
            ky = Number(document.getElementById("y_scale_input").value);
            X = Number(document.getElementById("x_coord_scale_input").value);
            Y = Number(document.getElementById("y_coord_scale_input").value);
            scale_polygon(kx, ky, X, Y);
        }
        function start_scaling_back_polygon_around_user_dot() {
            kx = Number(document.getElementById("x_scale_input").value);
            ky = Number(document.getElementById("y_scale_input").value);
            X = Number(document.getElementById("x_coord_scale_input").value);
            Y = Number(document.getElementById("y_coord_scale_input").value);
            scale_polygon_back(kx, ky, X, Y);
        }
        function turn_polygon(angle, X, Y) {
            const cos = Math.cos(angle * Math.PI / 180);
            const sin = Math.sin(angle * Math.PI / 180);
            const rotationMatrix = [
                [cos, -sin, 0],
                [sin, cos, 0],
                [0, 0, 1]
            ];

            polygons = polygons.map(polygon => {
                return polygon.map(point => {
                    const x = point.x - X;
                    const y = point.y - Y;
                    const newPoint = [
                        x * rotationMatrix[0][0] + y * rotationMatrix[1][0] + rotationMatrix[2][0] + X,
                        x * rotationMatrix[0][1] + y * rotationMatrix[1][1] + rotationMatrix[2][1] + Y
                    ];
                    return { x: newPoint[0], y: newPoint[1] };
                });
            });
            drawPolygons();
        }
        function turn_polygon_back(angle, X, Y) {
            const cos = Math.cos(angle * Math.PI / 180);
            const sin = Math.sin(angle * Math.PI / 180);
            const rotationMatrix = [
                [cos, sin, 0],
                [-sin, cos, 0],
                [0, 0, 1]
            ];

            polygons = polygons.map(polygon => {
                return polygon.map(point => {
                    const x = point.x - X;
                    const y = point.y - Y;
                    const newPoint = [
                        x * rotationMatrix[0][0] + y * rotationMatrix[1][0] + rotationMatrix[2][0] + X,
                        x * rotationMatrix[0][1] + y * rotationMatrix[1][1] + rotationMatrix[2][1] + Y
                    ];
                    return { x: newPoint[0], y: newPoint[1] };
                });
            });
            drawPolygons();
        }
        function scale_polygon(kx, ky, X, Y) {
            const scaleMatrix = [
                [1 / kx, 0, 0],
                [0, 1 / ky, 0],
                [0, 0, 1]
            ];

            polygons = polygons.map(polygon => {
                return polygon.map(point => {
                    const x = point.x - X;
                    const y = point.y - Y;
                    const newPoint = [
                        x * scaleMatrix[0][0] + y * scaleMatrix[1][0] + scaleMatrix[2][0] + X,
                        x * scaleMatrix[0][1] + y * scaleMatrix[1][1] + scaleMatrix[2][1] + Y
                    ];
                    return { x: newPoint[0], y: newPoint[1] };
                });
            });
            drawPolygons();
        }
        function scale_polygon_back(kx, ky, X, Y) {
            const scaleMatrix = [
                [kx, 0, 0],
                [0, ky, 0],
                [0, 0, 1]
            ];

            polygons = polygons.map(polygon => {
                return polygon.map(point => {
                    const x = point.x - X;
                    const y = point.y - Y;
                    const newPoint = [
                        x * scaleMatrix[0][0] + y * scaleMatrix[1][0] + scaleMatrix[2][0] + X,
                        x * scaleMatrix[0][1] + y * scaleMatrix[1][1] + scaleMatrix[2][1] + Y
                    ];
                    return { x: newPoint[0], y: newPoint[1] };
                });
            });
            drawPolygons();
        }

        function checkPoly() {
            document.getElementById("res").innerHTML = "";
            lastPoly = polygons[polygons.length - 1];
            for (i = 1; i <= lastPoly.length - 1; i++) {
                var curX = lastPoly[i].x - lastPoly[i - 1].x;
                var curY = lastPoly[i].y - lastPoly[i - 1].y;
                var curChechX = CheckX - lastPoly[i - 1].x;
                var curChechY = CheckY - lastPoly[i - 1].y;
                formula = curChechY * curX - curChechX * curY;
                formula2 = CheckY * lastPoly[i].x - CheckX * lastPoly[i].y;
                // console.log(`${formula}`);
                if (formula > 0) {
                    console.log("r");
                    document.getElementById("res").innerHTML += `ребро${i}:справа<br/>`;
                }
                else {
                    console.log("l");
                    document.getElementById("res").innerHTML += `ребро${i}: слева<br/>`;
                }

            }
            lastX = lastPoly[0].x - lastPoly[lastPoly.length - 1].x;
            lastY = lastPoly[0].y - lastPoly[lastPoly.length - 1].y;
            lastCheckX = CheckX - lastPoly[lastPoly.length - 1].x;
            lastCheckY = CheckY - lastPoly[lastPoly.length - 1].y;

            formula3 = lastCheckY * lastX - lastCheckX * lastY;
            // console.log(`${formula3}`);
            if (formula3 > 0) {
                console.log("r");
                document.getElementById("res").innerHTML += `ребро${i}:справа<br/>`;
            }
            else {
                console.log("l");
                document.getElementById("res").innerHTML += `ребро${i}: слева<br/>`;
            }


        }


    </script>
</body>

</html>