<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Многогранник на Canvas</title>
    <style>
        canvas {
            border: 1px solid black;
        }

        /* #scale {
            width: 25px;
            height: 25px;
            font-size: 15px;
        } */
        #main {
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;

        }
    </style>
    <script src="point-script.js"></script>
    <script src="polygon-script.js"></script>
    <script src="polyhedron-script.js"></script>
</head>

<body>

    <div id="main">
        <canvas id="canvas" width="1000" height="800"></canvas>
        <label>
            Поворот по X: <input type="range" id="rotateX" min="0" max="360" step="0.1" value="0">
        </label>
        <label>
            Поворот по Y: <input type="range" id="rotateY" min="0" max="360" step="0.1" value="0">
        </label>
        <label>
            Поворот по Z: <input type="range" id="rotateZ" min="0" max="360" step="0.1" value="0">
        </label>
        <label>
            Масштаб: <input type="range" id="scale" min="0.1" max="10" step="0.1" value="1">
        </label>
        <div>
            <select id="reflect" onchange="reflection()">
                <option value="x">Относительно X</option>
                <option value="y">Относительно Y</option>
                <option value="z">Относительно Z</option>
            </select>
            <select id="platonics" onchange="platonicSolids()">
                <option>Многогранник</option>
                <option value="1">тетраэдр</option>
                <option value="2">гексаэдр</option>
                <option value="3">октаэдр</option>
            </select>

            <button onclick="change_projection()">Изменить проекцию</button>
        </div>
    </div>

    <!-- <button id="scale" value="+" onclick="scale_bigger()">+</button>
    <button id="scale" value="-" onclick="scale_smaller()">-</button> -->
    <script>
<<<<<<< HEAD
        // Создаем тетраэдр
        // const plh = new Polyhedron([
        //     new Polygon([new Point(100, 100, 100), new Point(100, -100, -100), new Point(-100, 100, -100)]),
        //     new Polygon([new Point(100, 100, 100), new Point(100, -100, -100), new Point(-100, -100, 100)]),
        //     new Polygon([new Point(100, 100, 100), new Point(-100, 100, -100), new Point(-100, -100, 100)]),
        //     new Polygon([new Point(-100, 100, -100), new Point(100, -100, -100), new Point(-100, -100, 100)]),
        // ]);



        const tetrahedron = new Polyhedron([
=======
         /*const tetrahedron = new Polyhedron([
>>>>>>> cbca70e5551d7b5f940300cd27865ebb9958e3a7
            new Polygon([new Point(100, 100, 100), new Point(100, -100, -100), new Point(-100, 100, -100)]),
            new Polygon([new Point(100, 100, 100), new Point(100, -100, -100), new Point(-100, -100, 100)]),
            new Polygon([new Point(100, 100, 100), new Point(-100, 100, -100), new Point(-100, -100, 100)]),
            new Polygon([new Point(-100, 100, -100), new Point(100, -100, -100), new Point(-100, -100, 100)]),
<<<<<<< HEAD
        ])

        const gexahedron = new Polyhedron([
            new Polygon([new Point(0, 0, 0), new Point(0, 100, 0), new Point(100, 100, 0), new Point(100, 0, 0)]),
            new Polygon([new Point(0, 0, 0), new Point(0, 0, 100), new Point(100, 0, 100), new Point(100, 0, 0)]),
            new Polygon([new Point(0, 0, 0), new Point(0, 100, 0), new Point(0, 100, 100), new Point(0, 0, 100)]),
            new Polygon([new Point(100, 100, 100), new Point(100, 0, 100), new Point(0, 0, 100), new Point(0, 100, 100)]),
            new Polygon([new Point(100, 100, 100), new Point(100, 0, 100), new Point(100, 0, 0), new Point(100, 100, 0)]),
            new Polygon([new Point(100, 100, 100), new Point(100, 100, 0), new Point(0, 100, 0), new Point(0, 100, 100)]),
        ])

        const octahedron = new Polyhedron([
            new Polygon([new Point(50, 100, 50), new Point(50, 50, 0), new Point(100, 50, 50)]),
            new Polygon([new Point(50, 100, 50), new Point(100, 50, 50), new Point(50, 50, 100)]),
            new Polygon([new Point(50, 100, 50), new Point(50, 50, 100), new Point(0, 50, 50)]),
            new Polygon([new Point(50, 100, 50), new Point(0, 50, 50), new Point(50, 50, 0)]),
            //нижняя половина
            new Polygon([new Point(50, 0, 50), new Point(50, 50, 0), new Point(100, 50, 50)]),
            new Polygon([new Point(50, 0, 50), new Point(100, 50, 50), new Point(50, 50, 100)]),
            new Polygon([new Point(50, 0, 50), new Point(50, 50, 100), new Point(0, 50, 50)]),
            new Polygon([new Point(50, 0, 50), new Point(0, 50, 50), new Point(50, 50, 0)])

        ])

        function mxp(matrix, point) {
            let [x, y, z] = point;
            return [
                matrix[0][0] * x + matrix[0][1] * y + matrix[0][2] * z + matrix[0][3],
                matrix[1][0] * x + matrix[1][1] * y + matrix[1][2] * z + matrix[1][3],
                matrix[2][0] * x + matrix[2][1] * y + matrix[2][2] * z + matrix[2][3],
                matrix[3][0] * x + matrix[3][1] * y + matrix[3][2] * z + matrix[3][3]
            ];
        }

        function getRotationXMatrix(angle) {
            return [
                [1, 0, 0, 0],
                [0, Math.cos(angle), -Math.sin(angle), 0],
                [0, Math.sin(angle), Math.cos(angle), 0],
                [0, 0, 0, 1]
            ];
        }

        function getRotationYMatrix(angle) {
            return [
                [Math.cos(angle), 0, Math.sin(angle), 0],
                [0, 1, 0, 0],
                [-Math.sin(angle), 0, Math.cos(angle), 0],
                [0, 0, 0, 1]
            ];
        }

        function getRotationZMatrix(angle) {
            return [
                [Math.cos(angle), -Math.sin(angle), 0, 0],
                [Math.sin(angle), Math.cos(angle), 0, 0],
                [0, 0, 1, 0],
                [0, 0, 0, 1]
            ];
        }

        function getScaleMatrix(scale) {
            return [
                [scale, 0, 0, 0],
                [0, scale, 0, 0],
                [0, 0, scale, 0],
                [0, 0, 0, 1]
            ];
        }

=======
        ]);*/
>>>>>>> cbca70e5551d7b5f940300cd27865ebb9958e3a7

        // Создаем куб
        const tetrahedron = new Polyhedron([
            new Polygon([new Point(0, 100, 0), new Point(100, 100, 0), new Point(100, 100, 100), new Point(0, 100, 100)]),
            new Polygon([new Point(100, 100, 0), new Point(100, 100, 100), new Point(100, 0, 100), new Point(100, 0, 0)]),
            new Polygon([new Point(0, 100, 0), new Point(100, 100, 0), new Point(100, 0, 0), new Point(0, 0, 0)]),
            new Polygon([new Point(0, 100, 100), new Point(100, 100, 100), new Point(100, 0, 100), new Point(0, 0, 100)]),
            new Polygon([new Point(0, 100, 0), new Point(0, 100, 100), new Point(0, 0, 100), new Point(0, 0, 0)]),
            new Polygon([new Point(0, 0, 0), new Point(100, 0, 0), new Point(100, 0, 100), new Point(0, 0, 100)]),
        ]);
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let projection = 'perspective';
        const ref = document.getElementById('reflect');
        const plat = document.getElementById("platonics");
        let rotateX = 0, rotateY = 0, rotateZ = 0;
        scale = 1;
        //draw();

        function draw() {

            var nplh = plh;
            const rX = getRotationXMatrix(rotateX);
            const rY = getRotationYMatrix(rotateY);
            const rZ = getRotationZMatrix(rotateZ);
            const scaling = getScaleMatrix(scale);

            // const newVertices = plh.polygons.vertices.map(vertex => {
            //     let point = [...vertex,1];
            //     point = mxp(rX, point);
            //     point = mxp(rY, point);
            //     point = mxp(rZ, point);
            //     point = mxp(scaling, point);
            //     vertex[0] = point[0];
            //     vertex[1] = point[1];
            //     vertex[1] = point[1];
            // });

            //console.log(plh.polygons[1].vertices[0].coordinates[0]);
            // plh.polygons.forEach(polygon => {
            //     polygon.vertices = polygon.vertices.map(vertex => {
            //         const point = [...vertex.coordinates, 1];
            //         let transformed = mxp(rX, point);
            //         transformed = mxp(rY, transformed);
            //         transformed = mxp(rZ, transformed);
            //         transformed = mxp(scaling, transformed);

            //         vertex.coordinates = [transformed[0], transformed[1], transformed[2]];
            //     })
            // })

            nplh.polygons.forEach(vv => {
                vv.vertices.forEach(el =>{
                    console.log(`(${el.coordinates[0]};${el.coordinates[1]};${el.coordinates[2]})`);
                })
            });

            for (i = 0; i < plh.polygons.length; i++) {
                for (j = 0; j < plh.polygons[i].vertices.length; j++) {
                    let point = [...plh.polygons[i].vertices[j].coordinates,1];
                    point = mxp(rX,point);
                    point = mxp(rY,point);
                    point = mxp(rZ,point);
                    point = mxp(scaling,point);
                    nplh.polygons[i].vertices[j].coordinates = [point[0],point[1],point[2]];
                    //onsole.log(plh.polygons[i].vertices[j]);
                }
                //console.log("-------------------");
            }

            nplh.polygons.forEach(vv => {
                vv.vertices.forEach(el =>{
                    console.log(`(${el.coordinates[0]};${el.coordinates[1]};${el.coordinates[2]})`);
                })
            });
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            nplh.draw(ctx, projection);
        }


        function platonicSolids() {
            ctx.clearRect(0, 0, ctx.width, ctx.height);
            switch (plat.value) {
                case "1":
                    plh = tetrahedron;
                    break;
                case "2":
                    plh = gexahedron;
                    break;
                case "3":
                    plh = octahedron;
                    break;
            }
            draw();
        }

        function reflection() {
            plh.reflect(ref.value); // Отражение
            draw();
        }

        function scale_bigger() {
            plh.scale(1.5);
            draw();
        }
        function scale_smaller() {
            plh.scale(0.5);
            draw();
        }

        function change_projection() {
            projection = projection === 'perspective' ? 'axonometric' : 'perspective';
            draw();
        }

        document.getElementById('rotateX').addEventListener('input', (e) => {
            rotateX = parseFloat(e.target.value) * Math.PI / 180;
            draw();
        });

        document.getElementById('rotateY').addEventListener('input', (e) => {
            rotateY = parseFloat(e.target.value) * Math.PI / 180;
            draw();
        });

        document.getElementById('rotateZ').addEventListener('input', (e) => {
            rotateZ = parseFloat(e.target.value) * Math.PI / 180;
            draw();
        });

        document.getElementById('scale').addEventListener('input', (e) => {
            scale = parseFloat(e.target.value);
            draw();
        });
    </script>
</body>

</html>
